<?php declare(strict_types=1);

/*
 Copyright (c) 2024, Manticore Software LTD (https://manticoresearch.com)

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License version 3 or any later
 version. You should have received a copy of the GPL license along with this
 program; if you did not, you can find it at http://www.gnu.org/
 */

namespace Manticoresearch\Buddy\Base\Plugin\EmulateElastic\KibanaSearch\RequestNode;

use Manticoresearch\Buddy\Base\Plugin\EmulateElastic\KibanaSearch\RequestNode\Helpers\TimeZoneExpression;

/**
 *  Date range node of Kibana search request
 */
final class DateRange extends BaseRange {

	const EXPR_FUNC = 'date_range';

	/** @var string $timezoneOffsetExpr */
	private string $timezoneOffsetExpr = '';
	/** @var array<int,int>> $rangeMap */
	private array $rangeMap = [];
	/** @var array<int,array{from:string,to:string}> $origRanges */
	private array $origRanges = [];

	/**
	 * @param string $key
	 * @param string $argField
	 * @param array<int,array{from:string,to:string}> $ranges
	 * @param string $timezone
	 * @param TimeZoneExpression $timeZoneExpression
	 */
	public function __construct(
		protected string $key,
		protected string $argField,
		protected array $ranges,
		private string $timezone,
		private TimeZoneExpression $timeZoneExpression
	) {
		$this->makeRangeMap();
		$this->quoteRangeVals();
	}

	/**
	 * @return void
	 */
	protected function makeRangeMap(): void {
		// Sorting date ranges by their 'from' dates as it's done in Elastic
		$this->origRanges = $this->ranges;
		uasort(
			$this->origRanges,
			fn ($r1, $r2) => $r1['from'] > $r2['from'] ? 1 : 0
		);
		$this->rangeMap = array_flip(
			array_keys($this->origRanges)
		);
	}

	/**
	 * @return void
	 */
	protected function quoteRangeVals(): void {
		foreach ($this->ranges as $i => $range) {
			if ($range['from']) {
				$this->ranges[$i]['from'] = "'{$range['from']}'";
			}
			if (!$range['to']) {
				return;
			}
			$this->ranges[$i]['to'] = "'{$range['to']}'";
		}
	}

	/**
	 * @param array<int,array<string,mixed>> $buckets
	 * @return void
	 */
	protected function initResponseBuckets(array &$buckets): void {
		foreach ($this->origRanges as $range) {
			$newBucket = [
				'doc_count' => 0,
			];
			if ($range['from']) {
				$from = (int)strtotime($range['from']);
				$fromAsString = substr(date('Y-m-d\TH:i:s\.u', $from), 0, -3) . $this->timezoneOffsetExpr;
				$newBucket += [
					'from' => $from * 1000,
					'from_as_string' => $fromAsString,
					'key' => $fromAsString,
				];
			}
			if ($range['to']) {
				$to = (int)strtotime($range['to']);
				$toAsString = substr(date('Y-m-d\TH:i:s\.u', $to), 0, -3) . $this->timezoneOffsetExpr;
				$newBucket += [
					'to' => $to * 1000,
					'to_as_string' => $toAsString,
				];
				$newBucket['key'] = array_key_exists('key', $newBucket)
					? $newBucket['key'] . "-$toAsString"
					: $toAsString;
			}
			$buckets[] = $newBucket;
		}
	}

	/**
	 * @return void
	 */
	public function fillInRequest(): void {
		parent::fillInRequest();
		$this->request->addOrderField($this->argField, 'asc');
	}

	/**
	 * @param array<string,mixed> $responseNode
	 * @param array<string,mixed> $responseRow
	 * @param string $nextNodeKey
	 * @return array<string|int>|false
	 */
	public function fillInResponse(array &$responseNode, array $responseRow, string $nextNodeKey): array|false {
		if (!$this->aliasedFieldExpr) {
			$this->aliasedFieldExpr = $this->fieldAlias ?: $this->fieldExpr;
		}
		if (!$this->timezoneOffsetExpr) {
			$this->timezoneOffsetExpr = $this->timeZoneExpression->makeTimezoneExpr($this->timezone);
		}
		$this->makeResponseBucketsIfNotExist($responseNode);
		$buckets = &$responseNode[$this->key]['buckets'];
		if (!$buckets) {
			$this->initResponseBuckets($responseNode[$this->key]['buckets']);
		}
		if (!array_key_exists($this->aliasedFieldExpr, $responseRow)
			|| !is_numeric($responseRow[$this->aliasedFieldExpr])) {
			return [];
		}
		$rangeInd = (int)$responseRow[$this->aliasedFieldExpr];
		// Ignoring the 'other' range generated by Manticore but not needed for Kibana
		if (!array_key_exists($rangeInd, $buckets)) {
			return false;
		}
		$rangeBucket = &$buckets[(int)$this->rangeMap[$rangeInd]];
		// Create an empty object for the bucket's sub-data if it doesn't exist yet
		if (!array_key_exists($nextNodeKey, $rangeBucket)) {
			$rangeBucket[$nextNodeKey] = [];
		}
		$rangeBucket['doc_count'] += $responseRow[$this->countField];

		return [$this->key, 'buckets', (string)$rangeInd];
	}
}
